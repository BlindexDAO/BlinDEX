{
  "address": "0x029d1DCcbD7CfF8C7BB8318d6f54BcfD59d06052",
  "abi": [
    {
      "inputs": [],
      "name": "COLLATERAL_RATIO_MAX",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "COLLATERAL_RATIO_PRECISION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PRICE_PRECISION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "col_price",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "collateral_amount_d18",
          "type": "uint256"
        }
      ],
      "name": "calcMint1t1BD",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "bdx_price_fiat_d12",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bdx_amount_d18",
          "type": "uint256"
        }
      ],
      "name": "calcMintAlgorithmicBD",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "collateral_amount_d18",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "col_price",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "global_collat_value",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bdStable_total_supply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "global_collateral_ratio",
          "type": "uint256"
        }
      ],
      "name": "calcRecollateralizeBdStableInner",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xb27c21193c6ad1ba56607066b61c5f39d1b05cfed18664b0d2a15e11ee21f689",
  "receipt": {
    "to": null,
    "from": "0x774289Cb40c98B4f5b64a152BF7e5F94Fee38669",
    "contractAddress": "0x029d1DCcbD7CfF8C7BB8318d6f54BcfD59d06052",
    "transactionIndex": 1,
    "gasUsed": "285401",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd8716c20e74ef87620b9eee2929a813653409b4d4a5baf5a4f633d1613944bc5",
    "transactionHash": "0xb27c21193c6ad1ba56607066b61c5f39d1b05cfed18664b0d2a15e11ee21f689",
    "logs": [],
    "blockNumber": 3889374,
    "cumulativeGasUsed": "496805",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "cd8720e2909469f7fade4e9f8329e216",
  "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"COLLATERAL_RATIO_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COLLATERAL_RATIO_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"col_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral_amount_d18\",\"type\":\"uint256\"}],\"name\":\"calcMint1t1BD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bdx_price_fiat_d12\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bdx_amount_d18\",\"type\":\"uint256\"}],\"name\":\"calcMintAlgorithmicBD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral_amount_d18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collat_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bdStable_total_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collateral_ratio\",\"type\":\"uint256\"}],\"name\":\"calcRecollateralizeBdStableInner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/BdStable/Pools/BdPoolLibrary.sol\":\"BdPoolLibrary\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xcc78a17dd88fa5a2edc60c8489e2f405c0913b377216a5b26b35656b2d0dab52\",\"license\":\"MIT\"},\"contracts/BdStable/Pools/BdPoolLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary BdPoolLibrary {\\n    using SafeMath for uint256;\\n\\n    // Constants for various precisions\\n    uint256 public constant PRICE_PRECISION = 1e12;\\n    uint256 public constant COLLATERAL_RATIO_PRECISION = 1e12;\\n    uint256 public constant COLLATERAL_RATIO_MAX = 1e12;\\n\\n    // ================ Functions ================\\n\\n    function calcMint1t1BD(uint256 col_price, uint256 collateral_amount_d18) external pure returns (uint256) {\\n        return (collateral_amount_d18.mul(col_price)).div(PRICE_PRECISION);\\n    }\\n\\n    function calcMintAlgorithmicBD(uint256 bdx_price_fiat_d12, uint256 bdx_amount_d18) external pure returns (uint256) {\\n        return bdx_amount_d18.mul(bdx_price_fiat_d12).div(PRICE_PRECISION);\\n    }\\n\\n\\n    // Must be internal because of the struct\\n    function calcMintFractionalBD(uint256 bdx_price_fiat_d12, uint256 col_price_fiat_d12, uint256 collateral_amount_d18, uint256 col_ratio_d12) internal pure returns (uint256, uint256) {\\n        // Since solidity truncates division, every division operation must be the last operation in the equation to ensure minimum error\\n        // The contract must check the proper ratio was sent to mint BdStable. We do this by seeing the minimum mintable BdStable based on each amount \\n\\n        uint256 c_fiat_value_d18 = collateral_amount_d18.mul(col_price_fiat_d12).div(PRICE_PRECISION);\\n        \\n        uint calculated_bdx_fiat_value_d18 = \\n                    (c_fiat_value_d18.mul(COLLATERAL_RATIO_PRECISION).div(col_ratio_d12))\\n                    .sub(c_fiat_value_d18);\\n\\n        uint calculated_bdx_needed = calculated_bdx_fiat_value_d18.mul(PRICE_PRECISION).div(bdx_price_fiat_d12);\\n\\n        return (\\n            c_fiat_value_d18.add(calculated_bdx_fiat_value_d18),\\n            calculated_bdx_needed\\n        );\\n    }\\n\\n    function calcRecollateralizeBdStableInner(\\n        uint256 collateral_amount_d18,\\n        uint256 col_price,\\n        uint256 global_collat_value,\\n        uint256 bdStable_total_supply,\\n        uint256 global_collateral_ratio\\n    ) external pure returns (uint256, uint256) {\\n        uint256 collat_value_attempted = collateral_amount_d18.mul(col_price).div(PRICE_PRECISION);\\n        uint256 effective_collateral_ratio = global_collat_value.mul(PRICE_PRECISION).div(bdStable_total_supply); //returns it in 1e12\\n        uint256 recollat_possible = global_collateral_ratio.sub(effective_collateral_ratio).mul(bdStable_total_supply).div(COLLATERAL_RATIO_PRECISION);\\n\\n        uint256 amount_to_recollat;\\n        if(collat_value_attempted <= recollat_possible){\\n            amount_to_recollat = collat_value_attempted;\\n        } else {\\n            amount_to_recollat = recollat_possible;\\n        }\\n\\n        return (amount_to_recollat.mul(PRICE_PRECISION).div(col_price), amount_to_recollat);\\n    }\\n\\n    // Must be internal because of the struct\\n    function calcBuyBackBDX(uint256 excess_collateral_fiat_value_d18, uint256 bdx_price_fiat_d12, uint256 col_price_fiat_d12, uint256 bdx_amount_d18) internal pure returns (uint256) {\\n        // If the total collateral value is higher than the amount required at the current collateral ratio then buy back up to the possible BDX with the desired collateral\\n        require(excess_collateral_fiat_value_d18 > 0, \\\"No excess collateral to buy back!\\\");\\n\\n        // Make sure not to take more than is available\\n        uint256 bdx_fiat_value_d18 = bdx_amount_d18.mul(bdx_price_fiat_d12).div(PRICE_PRECISION);\\n        require(bdx_fiat_value_d18 <= excess_collateral_fiat_value_d18, \\\"You are trying to buy back more than the excess!\\\");\\n\\n        // Get the equivalent amount of collateral based on the market value of BDX provided \\n        uint256 collateral_equivalent_d18 = bdx_fiat_value_d18.mul(PRICE_PRECISION).div(col_price_fiat_d12);\\n\\n        return (\\n            collateral_equivalent_d18\\n        );\\n    }\\n}\",\"keccak256\":\"0x87a59eecf63f51a219d2093392af50b606eedae0955d77cf58a8ee2cf94e138d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x61036b610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061006c5760003560e01c80634e820a3f14610071578063810278f01461009b57806395082d25146100bb578063ba8b18081461009b578063d07ac67e146100bb578063dd89fe0a146100bb575b600080fd5b61008461007f366004610235565b6100c3565b604051610092929190610327565b60405180910390f35b6100ae6100a9366004610214565b610150565b604051610092919061031e565b6100ae61016e565b600080806100e064e8d4a510006100da8a8a610177565b906101ba565b905060006100f7866100da8964e8d4a51000610177565b9050600061011864e8d4a510006100da896101128a876101ec565b90610177565b9050600081841161012a57508261012d565b50805b6101408a6100da8364e8d4a51000610177565b9b909a5098505050505050505050565b600061016564e8d4a510006100da8486610177565b90505b92915050565b64e8d4a5100081565b60008261018657506000610168565b8282028284828161019357fe5b04146101655760405162461bcd60e51b81526004016101b1906102dd565b60405180910390fd5b60008082116101db5760405162461bcd60e51b81526004016101b1906102a6565b8183816101e457fe5b049392505050565b60008282111561020e5760405162461bcd60e51b81526004016101b19061026f565b50900390565b60008060408385031215610226578182fd5b50508035926020909101359150565b600080600080600060a0868803121561024c578081fd5b505083359560208501359550604085013594606081013594506080013592509050565b6020808252601e908201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604082015260600190565b6020808252601a908201527f536166654d6174683a206469766973696f6e206279207a65726f000000000000604082015260600190565b60208082526021908201527f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f6040820152607760f81b606082015260800190565b90815260200190565b91825260208201526040019056fea2646970667358221220d68c0837dae1b0b3f1c91a6da445619e146b6aabce74baf64540a37423de291764736f6c634300060c0033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061006c5760003560e01c80634e820a3f14610071578063810278f01461009b57806395082d25146100bb578063ba8b18081461009b578063d07ac67e146100bb578063dd89fe0a146100bb575b600080fd5b61008461007f366004610235565b6100c3565b604051610092929190610327565b60405180910390f35b6100ae6100a9366004610214565b610150565b604051610092919061031e565b6100ae61016e565b600080806100e064e8d4a510006100da8a8a610177565b906101ba565b905060006100f7866100da8964e8d4a51000610177565b9050600061011864e8d4a510006100da896101128a876101ec565b90610177565b9050600081841161012a57508261012d565b50805b6101408a6100da8364e8d4a51000610177565b9b909a5098505050505050505050565b600061016564e8d4a510006100da8486610177565b90505b92915050565b64e8d4a5100081565b60008261018657506000610168565b8282028284828161019357fe5b04146101655760405162461bcd60e51b81526004016101b1906102dd565b60405180910390fd5b60008082116101db5760405162461bcd60e51b81526004016101b1906102a6565b8183816101e457fe5b049392505050565b60008282111561020e5760405162461bcd60e51b81526004016101b19061026f565b50900390565b60008060408385031215610226578182fd5b50508035926020909101359150565b600080600080600060a0868803121561024c578081fd5b505083359560208501359550604085013594606081013594506080013592509050565b6020808252601e908201527f536166654d6174683a207375627472616374696f6e206f766572666c6f770000604082015260600190565b6020808252601a908201527f536166654d6174683a206469766973696f6e206279207a65726f000000000000604082015260600190565b60208082526021908201527f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f6040820152607760f81b606082015260800190565b90815260200190565b91825260208201526040019056fea2646970667358221220d68c0837dae1b0b3f1c91a6da445619e146b6aabce74baf64540a37423de291764736f6c634300060c0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}